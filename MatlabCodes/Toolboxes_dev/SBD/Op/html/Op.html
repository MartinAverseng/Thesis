
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Op</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-03-09"><meta name="DC.source" content="Op.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Constructor</a></li><li><a href="#4">Argument Parsing</a></li><li><a href="#5">Preparing data and rescaling</a></li><li><a href="#6">Create the operator</a></li><li><a href="#8">Far operator</a></li><li><a href="#9">Local Part</a></li><li><a href="#12">Immediate properties</a></li><li><a href="#13">Setters</a></li><li><a href="#15">Local Part</a></li><li><a href="#17">Display</a></li><li><a href="#18">Others</a></li></ul></div><pre class="codeinput"><span class="keyword">classdef</span> Op &lt; AbstractMatrix
    <span class="comment">% Op objects represent a matrix A which elements are given by</span>
    <span class="comment">% A(i,j) = G(|X(i) - Y(j)|) for some set of points X and Y. However, this</span>
    <span class="comment">% object does not store the full matrix, instead it uses a Fourier</span>
    <span class="comment">% approximation to reduce the amount of data stored and the time needed</span>
    <span class="comment">% for computing a Matrix-Vector product.</span>
    <span class="keyword">properties</span>
        rMax = 0; <span class="comment">% when the user inputs X and Y as data set, rMax is an upper</span>
        <span class="comment">% bound of the maximal distance between a point in X and a point in</span>
        <span class="comment">% Y. The data set are then rescaled by X/rMax and Y/rMax</span>
        x = [];
        y = []; <span class="comment">% rescaled data</span>
        kernel@Kernel = Kernel;<span class="comment">% Kernel object. It contains the function G and other information needed for the method</span>
        a = 1; <span class="comment">% Bounds of the radial quadrature</span>
        tol = 0; <span class="comment">% required accuracy of the approximation</span>
        rq@RadialQuadrature = RadialQuadrature;
        q2d@Quad2D = Quad2D; <span class="comment">% Quad2D object, computes the far interaction</span>
        timesClose = struct(<span class="string">'total'</span>,0,<span class="string">'computeInteractions'</span>,0,<span class="string">'computingTree'</span>,NaN,<span class="string">'rangeSearch'</span>,NaN,<span class="keyword">...</span>
            <span class="string">'NUFFTcloseField'</span>,NaN,<span class="string">'assemble'</span>,0);
        timeTotalAssembling = 0; <span class="comment">% Timing info</span>
        full = false;
        Y_kdtree = [];
        rxy;
        verbose;
    <span class="keyword">end</span>

    <span class="keyword">methods</span> (Access = public)
</pre><h2>Constructor<a name="2"></a></h2><pre class="codeinput">        <span class="keyword">function</span>[op] = Op(X,k,Y,varargin)
</pre><pre class="codeinput">            op@AbstractMatrix([],[],0,0);
            tTotalAssembling = tic;
            <span class="keyword">if</span> nargin == 0
                <span class="comment">% Empty Op.</span>
                <span class="keyword">return</span>
            <span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

</pre><h2>Argument Parsing<a name="4"></a></h2><pre class="codeinput">            p = inputParser;
            p.KeepUnmatched = true;
            p.addOptional(<span class="string">'noCloseField'</span>,false); <span class="comment">% Set to true to disable close field</span>
            <span class="comment">% This is useful when you know that clouds XX and YY are far</span>
            <span class="comment">% apart.</span>
            p.addOptional(<span class="string">'principalPart'</span>,false); <span class="comment">% Turn this on if you</span>
            <span class="comment">% want to compute the Operator</span>
            <span class="comment">% A(i,j&agrave; = G_loc|X(i) - Y(j)|</span>
            <span class="comment">% Where G_loc is such that there exists a C^\infty function R</span>
            <span class="comment">% with</span>
            <span class="comment">% G_loc + R = G</span>
            p.addOptional(<span class="string">'fullMatrix'</span>,false);
            p.addOptional(<span class="string">'a'</span>,Op.default_a(size(X,1),size(Y,1))); p.addOptional(<span class="string">'a_factor'</span>,1);
            p.addOptional(<span class="string">'tol'</span>,1e-8); p.addOptional(<span class="string">'precomputedRadialQuad'</span>,[]);
            p.addOptional(<span class="string">'precomputedKDtree'</span>,[]);
            p.addOptional(<span class="string">'rMax'</span>,Op.rMaxCalc(X,Y));
            p.addOptional(<span class="string">'verbose'</span>,1);
            <span class="comment">% If user wishes to compute a radial quad with specific option,</span>
            <span class="comment">% or use several times the same radialquad for different Op</span>
            <span class="comment">% object, this is the way to pass it as an argument.</span>
            p.parse(varargin{:});
            optVars = p.Results;
            op.Y_kdtree = optVars.precomputedKDtree;
</pre><h2>Preparing data and rescaling<a name="5"></a></h2><pre class="codeinput">            op.rMax = optVars.rMax;
            op.x = X/op.rMax;
            op.y = Y/op.rMax;
            op.N1 = size(X,1);
            op.N2 = size(Y,1);
            op.kernel = k.dilatation(op.rMax);
            op.verbose = optVars.verbose;
</pre><h2>Create the operator<a name="6"></a></h2><pre class="codeinput">            <span class="keyword">if</span> optVars.fullMatrix
                <span class="comment">% The operator is fully assembled.</span>

                <span class="comment">% the timing information are normally set by the call to</span>
                <span class="comment">% Radial</span>
                op = op.computeFullMatrix;
                <span class="comment">% Computes all the Nx*Ny interactions</span>
                <span class="comment">% Also sets the timesClose struct.</span>
            <span class="keyword">else</span>
</pre><pre class="codeinput">                <span class="comment">% A radial quadrature is performed on the kernel for the</span>
                <span class="comment">% far interactions</span>
                <span class="comment">% Local interactions are computed explicitly</span>
                op.tol = optVars.tol;
                op.a = optVars.a_factor*optVars.a;
</pre><h2>Far operator<a name="8"></a></h2><pre class="codeinput">                <span class="keyword">if</span> isempty(optVars.precomputedRadialQuad)
                    op.rq = op.kernel.radialQuadKernel(op.a,op.tol,varargin{:});
                <span class="keyword">else</span>
                    op.rq = optVars.precomputedRadialQuad;
                <span class="keyword">end</span>
                op.q2d = Quad2D(op.rq);
</pre><h2>Local Part<a name="9"></a></h2><pre class="codeinput">                <span class="keyword">if</span> ~or(isa(op.kernel,<span class="string">'J0Kernel'</span>),optVars.noCloseField)
                    op = createLocalPart(op);
                    <span class="comment">% Computes the local interactions</span>
                    <span class="comment">% Also sets the timesClose struct;</span>
                <span class="keyword">else</span>
                    <span class="comment">% No need to compute the close interactions.</span>
                    op.concretePart = sparse([],[],[],op.N1,op.N2);
                    <span class="keyword">if</span> optVars.noCloseField
                        rMinTest = op.rMinTest;
                        <span class="keyword">if</span> rMinTest &lt; op.a*op.rMax
                            warning([<span class="string">'There are pairs of points closer than '</span>, <span class="keyword">...</span>
                            <span class="string">'parameter ''a''. It was however requested not '</span>,<span class="keyword">...</span>
                            <span class="string">'to compute the local interactions. This may lead to'</span>,<span class="keyword">...</span>
                            <span class="string">' inaccurate results'</span>]);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> optVars.principalPart
                    <span class="comment">% Erase the radial quadratue components</span>
                    op.rq = RadialQuadrature;
                    op.q2d = Quad2D;
                <span class="keyword">end</span>
                op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
</pre><pre class="codeinput">            <span class="keyword">end</span>

            op.timeTotalAssembling = toc(tTotalAssembling);
</pre><pre class="codeinput">        <span class="keyword">end</span>
</pre><h2>Immediate properties<a name="12"></a></h2><pre class="codeinput">        <span class="keyword">function</span>[nxi] = Nxi(this,test_a)
            <span class="keyword">if</span> nargin == 1
                nxi = this.q2d.Nxi;
            <span class="keyword">else</span>
                rq_test = this.kernel.radialQuadKernel(test_a,this.tol);
                nxi = sum(fix(exp(1)/2*0.8*rq_test.rho + 5*log(1/(this.tol+10^(-10)))));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span>[out] = NCI(op,test_a)
            <span class="keyword">if</span> nargin == 1
                out = nnz(op.concretePart);
            <span class="keyword">else</span>
                <span class="keyword">if</span> isempty(op.Y_kdtree)
                    I = rangesearch(op.Y,op.X,op.rMax*test_a*1.05);
                <span class="keyword">else</span>
                    I = rangesearch(op.Y_kdtree,op.X,op.rMax*test_a*1.05);
                <span class="keyword">end</span>
                out = length(cell2mat(I')');
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span>[tFar] = timesFar(this)
            tFar.radialQuadrature = this.rq.times.total;
            tFar.quad2D = this.q2d.time;
            tFar.total = tFar.radialQuadrature + tFar.quad2D;
        <span class="keyword">end</span>
        <span class="keyword">function</span>[r] = rMinTest(this)
            <span class="comment">% First pass</span>
            x1 = this.x(1,:);
            [~,ind] = min(sqrt((x1(1) - this.y(:,1)).^2 + (x1(2) - this.y(:,2)).^2));
            y1 = this.y(ind,:);
            <span class="comment">% Second pass</span>
            [~,ind] = min(sqrt((this.x(:,1) - y1(1)).^2 + (this.x(:,2) - y1(2)).^2));
            x2 = this.x(ind,:);
            [~,ind] = min(sqrt((x2(1) - this.y(:,1)).^2 + (x2(2) - this.y(:,2)).^2));
            y2 = this.y(ind,:);
            <span class="comment">% Third pass</span>
            [~,ind] = min(sqrt((this.x(:,1) - y2(1)).^2 + (this.x(:,2) - y2(2)).^2));
            x3 = this.x(ind,:);
            [~,ind] = min(sqrt((x3(1) - this.y(:,1)).^2 + (x3(2) - this.y(:,2)).^2));
            y3 = this.y(ind,:);
            r = norm(x3 - y3,2)*this.rMax;
        <span class="keyword">end</span>
        <span class="keyword">function</span>[X] = X(op)
            X = op.x * op.rMax;
        <span class="keyword">end</span>
        <span class="keyword">function</span>[Y] = Y(op)
            Y = op.y * op.rMax;
        <span class="keyword">end</span>
        <span class="keyword">function</span>[out] = a_factor(op)
            <span class="comment">% Size of parameter a compared to default value.</span>
            out = op.a/Op.default_a(op.N1,op.N2);
        <span class="keyword">end</span>
</pre><pre class="codeoutput">Number of 2D quadrature points : 0
</pre><h2>Setters<a name="13"></a></h2><pre class="codeinput">        <span class="keyword">function</span>[op] = createLocalPart(op)
            times.rangeSearch = 0;
            times.computeInteractions = 0;
            times.NUFFTcloseField = 0;
            times.assemble = 0;
            tTotalTime = tic;
            <span class="comment">% Find close interactions</span>
            tRangeSearch = tic;
            times.computingTree = 0;
            <span class="keyword">if</span> isempty(op.Y_kdtree)
                tComputingTree = tic;
                op.Y_kdtree = KDTreeSearcher(op.Y);
                times.computingTree = toc(tComputingTree);
            <span class="keyword">end</span>
            [I,rxyTemp] = rangesearch(op.Y_kdtree,op.X,op.rMax*op.a*1.05);
            jdx = cell2mat(I')';
            op.rxy = cell2mat(rxyTemp')'/op.rMax;
            idx = zeros(size(jdx));
            sp_ind = 1;
            <span class="keyword">for</span> x_ind=1:length(I);
                idx(sp_ind:(sp_ind+length(I{x_ind})-1)) = x_ind;
                sp_ind = sp_ind + length(I{x_ind});
            <span class="keyword">end</span>
            <span class="comment">% Save memory</span>
            clear <span class="string">I</span>;
            times.rangeSearch = toc(tRangeSearch);
            NCI = length(op.rxy);
            Nxi = op.q2d.Nxi;
            <span class="comment">% close-field</span>
            <span class="keyword">if</span> NCI ~= 0
                tComputeInteractions = tic;
                rxyApply = op.rxy;
                rxyApply(rxyApply*op.rMax &lt; 1e-8) = 1e-8/op.rMax;
                B1_inds = op.kernel.func(rxyApply);
                <span class="comment">%B1_inds(or(isinf(B1_inds),isnan(B1_inds))) = op.kernel.func(1e-8/op.rMax);</span>

                times.computeInteractions = toc(tComputeInteractions);

                <span class="comment">% local correction of error due to NUFFT</span>
                <span class="keyword">if</span> op.verbose &gt;=1
                    fprintf(<span class="string">'NUFFT for local correction : *'</span>)
                <span class="keyword">end</span>
                tNUFFTcloseField = tic;
                B2_inds = nufft2d3(Nxi, op.q2d.xi_nu(:,1), op.q2d.xi_nu(:,2), <span class="keyword">...</span>
                    op.q2d.w_nu, +1, op.tol/10, length(idx),<span class="keyword">...</span>
                    op.x(idx,1) - op.y(jdx,1), op.x(idx,2) - op.y(jdx,2));
                times.NUFFTcloseField = toc(tNUFFTcloseField);

                <span class="comment">% Sparse matrix</span>
                tAssemble = tic;
                B_inds = B1_inds - B2_inds - op.q2d.offset;
                op.concretePart = sparse(idx,jdx,B_inds,op.N1,op.N2);
                times.assemble = toc(tAssemble);
            <span class="keyword">else</span>
                <span class="comment">% No close interactions</span>
                op.concretePart = sparse(op.N1,op.N2); <span class="comment">% all zeros</span>
            <span class="keyword">end</span>

            times.total = toc(tTotalTime);
            op.timesClose = times;

        <span class="keyword">end</span>
        <span class="keyword">function</span>[op] = update_X(op,X,varargin)
            tUpdating = tic;
            p = inputParser;
            p.addOptional(<span class="string">'a'</span>,op.a);
            p.addOptional(<span class="string">'tol'</span>,op.tol);
            p.addOptional(<span class="string">'principalPart'</span>,false);
            p.addOptional(<span class="string">'a_factor'</span>,1);
            p.parse(varargin{:});
            <span class="comment">% Replace the operator by A(i,j) = G(|X(i) - Y(j)|) with new X</span>
            <span class="comment">% data.</span>
            <span class="comment">% 1&deg;) New rescaling</span>
            rMaxNew = Op.rMaxCalc(X,op.Y);
            <span class="keyword">if</span> any([rMaxNew &gt; op.rMax,op.tol &gt; p.Results.tol, p.Results.a*p.Results.a_factor ~= op.a])
                <span class="comment">% Then we have to update the quadrature since it is not</span>
                <span class="comment">% valid up to rMaxTest or to requested tolerance</span>
                disp(<span class="string">'Recomputing a quadrature'</span>);
                rMaxPrevious = op.rMax;
                op.rMax = rMaxNew;
                op.x = X/op.rMax;
                op.y = op.y*rMaxPrevious/op.rMax;
                op.a = p.Results.a*p.Results.a_factor;
                op.N1 = size(X,1);
                op.kernel = op.kernel.dilatation(rMaxNew/rMaxPrevious);
                <span class="keyword">if</span> op.full
                    op = op.computeFullMatrix;
                <span class="keyword">else</span>
                    op.rq = op.kernel.radialQuadKernel(op.a,op.tol);
                    op.q2d = Quad2D(op.rq);
                    <span class="keyword">if</span> p.Results.principalPart
                        <span class="comment">% Erase the radial quadratue components</span>
                        op.rq = RadialQuadrature;
                        op.q2d = Quad2D;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="comment">% We can reuse the previous quadrature</span>
                op.x = X/op.rMax;
                op.N1 = size(X,1);
            <span class="keyword">end</span>
            op = op.createLocalPart;
            op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
            op.timeTotalAssembling = toc(tUpdating);
        <span class="keyword">end</span>
        <span class="keyword">function</span>[op] = change_a(op,new_a)
</pre><pre class="codeinput">            op.a = new_a;
            op.rq = op.kernel.radialQuadKernel(op.a,op.tol);
            op.q2d = Quad2D(op.rq);
</pre><h2>Local Part<a name="15"></a></h2><p>If we decrease a, we just have to remove the pairs that are a bit too far.</p><pre class="codeinput">            <span class="keyword">if</span> ~isa(op.kernel,<span class="string">'J0Kernel'</span>)
                op = op.createLocalPart;
                <span class="comment">% Computes the local interactions</span>
                <span class="comment">% Also sets the timesClose struct</span>
            <span class="keyword">end</span>
            op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
</pre><pre class="codeinput">        <span class="keyword">end</span>
        <span class="keyword">function</span>[op] = balanceMemory(op)
            Nxi = op.Nxi;
            NCI = op.NCI;
            NCI0 = NCI;
            memClose = NCI*16;
            memFar = Nxi*24;
            alpha = 1; <span class="comment">% Guessed dependance of NCI in variable a.</span>
            dataAlpha = [];
            a0 = op.a;
            a_current = a0;
            <span class="keyword">while</span> or(memClose&gt;10*memFar,memClose &lt; memFar/10)
                <span class="comment">% Find out if memory usage is ok</span>
                lambdaGuess = (memFar/memClose)^(1/(alpha+2));
                a_current = lambdaGuess*a0;
                Nxi = op.Nxi(a_current);
                NCI = op.NCI(a_current);
                memClose = NCI*16;
                memFar = Nxi*24;
                dataAlpha = [dataAlpha,log(NCI/NCI0)/log(a_current/a0)];<span class="comment">%#ok</span>
                alpha = mean(dataAlpha);
            <span class="keyword">end</span>
            op = op.change_a(a_current);
        <span class="keyword">end</span>
        <span class="keyword">function</span>[op] = balanceTime(op)
            Vtest = randn(size(op,2),1);
            tClose = tic;
            q_close_test = op.concretePart*Vtest;<span class="comment">%#ok</span>
            tClose = toc(tClose);
            <span class="keyword">if</span> tClose &lt; 0.01
                tClose = tic;
                <span class="keyword">for</span> i = 1:10
                    q_close_test = op.concretePart*Vtest;<span class="comment">%#ok</span>
                <span class="keyword">end</span>
                tClose = toc(tClose)/10;
            <span class="keyword">end</span>
            tFar = tic;
            q_far_test = op.abstractPart(Vtest);<span class="comment">%#ok</span>
            tFar = toc(tFar);
            <span class="keyword">while</span> or(tClose&gt;5*tFar,tClose &lt; tFar/5)
                <span class="keyword">if</span> tClose &gt; tFar
                    lambda = 0.75;
                <span class="keyword">else</span>
                    lambda = 1.25;
                    <span class="keyword">try</span>
                        MemTest = ones(fix(1.5*op.NCI),1); <span class="comment">%#ok</span>
                        clear <span class="string">A</span>;
                    <span class="keyword">catch</span>
                        <span class="keyword">break</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> lambda*op.a &gt; 1
                    <span class="keyword">return</span>
                <span class="keyword">end</span>
                op = op.change_a(lambda*op.a);
                tClose = tic;
                q_close_test = op.concretePart*Vtest;<span class="comment">%#ok</span>
                tClose = toc(tClose);
                <span class="keyword">if</span> tClose &lt; 0.01
                    tClose = tic;
                    <span class="keyword">for</span> i = 1:10
                        q_close_test = op.concretePart*Vtest;<span class="comment">%#ok</span>
                    <span class="keyword">end</span>
                    tClose = toc(tClose)/10;
                <span class="keyword">end</span>
                tFar = tic;
                q_far_test = op.abstractPart(Vtest);<span class="comment">%#ok</span>
                tFar = toc(tFar);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span>[op] = computeFullMatrix(op)
            tTotalAssembling = tic;
            op.timesClose.rangesearch = 0;

            op.timesClose.NUFFTcloseField = 0;

            X1 = op.x(:,1); X2 = op.x(:,2);
            Y1 = op.y(:,1); Y2 = op.y(:,2);
            NX = length(X1);
            NY = length(Y1);
            tComputeInteractions = tic;
            X1_Y1 = repmat(X1,1,NY) - repmat(Y1',NX,1);
            X2_Y2 = repmat(X2,1,NY) - repmat(Y2',NX,1);
            rXY = sqrt(X1_Y1.^2 + X2_Y2.^2);
            op.timesClose.computeInteractions = toc(tComputeInteractions);
            op.concretePart = op.kernel.func(rXY);
            op.concretePart(or(isnan(op.concretePart),<span class="keyword">...</span>
                isinf(op.concretePart))) = op.kernel.func(1e-8/op.rMax);
            op.timeTotalAssembling = toc(tTotalAssembling);
            op.full = true;
            op.timesClose.total = toc(tTotalAssembling);
        <span class="keyword">end</span>
</pre><h2>Display<a name="17"></a></h2><pre class="codeinput">        <span class="keyword">function</span>[] = disp(this)
            printStarLine;
            fprintf(<span class="string">'GENERAL INFO \n'</span>)
            fprintf(<span class="string">'\nOperator of size %s x %s for kernel \n'</span>,num2str(size(this,1)),num2str(size(this,2)));
            disp(this.kernel.dilatation(1/this.rMax));
            <span class="keyword">if</span> this.full
                printStarLine;
                fprtinf(<span class="string">'Operator is FULLY assmbled \n'</span>);
            <span class="keyword">else</span>
                rm = this.rMin;
                rM = this.rMax;
                fprintf(<span class="string">'Close operator defined for r in [0, %.2f] \n'</span>,rm);
                fprintf(<span class="string">'Far operator defined for [%.2f, %.2f] \n'</span>,rm,rM);
                fprintf(<span class="string">'Number of close interactions : %s\n'</span>,num2str(this.NCI));
                fprintf(<span class="string">'Number of radial quadrature points : %s\n'</span>,num2str(length(this.rq.rho) - 1));
                fprintf(<span class="string">'Number of 2D quadrature points : %s\n'</span>,num2str(this.Nxi));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span>[] = show(this)
            disp(this);
            showTime(this);
            showPerf(this);
            show(this.rq);
        <span class="keyword">end</span>
        <span class="keyword">function</span>[] = showTime(this)
            printStarLine;
            tClose = this.timesClose.total;
            tFar = this.timesFar.total;
            tTot = tClose + tFar;
            <span class="keyword">if</span> this.full
                fprintf(<span class="string">'Operator assembled FULLY in %s s\n'</span>,tTot);
            <span class="keyword">else</span>
                fprintf(<span class="string">'OFFLINE PERFORMANCE \n'</span>)
                fprintf(<span class="string">'\n- Operator assembling : %.2f s  :\n'</span>,tTot);
                alinea =  <span class="string">'     '</span>;

                fprintf([alinea <span class="string">'- Close operator : %.2f s (%.2f %%): \n'</span>],tClose,tClose/tTot*100);
                <span class="keyword">if</span> this.timesClose.computingTree == 0
                    fprintf([alinea alinea <span class="string">'* KD-tree : 0 %% (precomputed)\n'</span>]);
                <span class="keyword">else</span>
                    fprintf([alinea alinea <span class="string">'* KD-tree : %.2f %% \n'</span>],this.timesClose.computingTree/tClose*100);
                <span class="keyword">end</span>
                fprintf([alinea alinea <span class="string">'* Range search : %.2f %% \n'</span>],this.timesClose.rangeSearch/tClose*100);
                fprintf([alinea alinea <span class="string">'* Computation of close interactions : %.2f %% \n'</span>],this.timesClose.computeInteractions/tClose*100);
                fprintf([alinea alinea <span class="string">'* Local correction of the far-field (NUFFT) : %.2f %% \n'</span>],this.timesClose.NUFFTcloseField/tClose*100);
                fprintf([alinea alinea <span class="string">'* Assembling close operator : %.2f %% \n'</span>],this.timesClose.assemble/tClose*100);


                fprintf([alinea <span class="string">'- Far operator : %.2f s (%.2f %%): \n'</span>],tFar,tFar/tTot*100);
                fprintf([alinea alinea <span class="string">'* Radial quadrature : %.2f %% \n'</span>],this.timesFar.radialQuadrature/tFar*100);
                fprintf([alinea alinea <span class="string">'* 2D quadrature : %.2f %% \n'</span>],this.timesFar.quad2D/tFar*100);
            <span class="keyword">end</span>

        <span class="keyword">end</span>
        <span class="keyword">function</span>[] = showPerf(this)
            printStarLine;
            alinea =  <span class="string">'     '</span>;

            fprintf(<span class="string">'ONLINE PERFORMANCE \n'</span>)
            <span class="comment">% Memory</span>
            fprintf(<span class="string">'\n- Memory allocation : %s \n'</span>,this.memorySize)
            <span class="keyword">if</span> this.full
                fprintf(<span class="string">'Operator is fully assembled \n'</span>)
            <span class="keyword">else</span>
                sparsityConst = this.NCI/(size(this,1)*size(this,2));
                fprintf([alinea <span class="string">'- Close operator : %.2f %% (%.2f %% sparsity)\n'</span>],this.NCI*2/(this.Nxi*3 + this.NCI*2)*100,100 - sparsityConst*100);
                fprintf([alinea <span class="string">'- Far operator : %.2f %%\n'</span>],this.Nxi/(this.Nxi + this.NCI)*100)
                <span class="keyword">if</span> (this.NCI*2 &gt; this.Nxi*3)
                    str_for_a = <span class="string">'reduce'</span>;
                <span class="keyword">else</span>
                    str_for_a = <span class="string">'increase'</span>;
                <span class="keyword">end</span>
                <span class="keyword">if</span> or(2*this.NCI &gt; 10*3*this.Nxi,2*this.NCI &lt; 1/10*3*this.Nxi)
                    fprintf(<span class="string">'(for more balanced memory allocation, %s parameter ''a'') \n'</span>,str_for_a);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Chrono of MV prod</span>
            <span class="keyword">if</span> this.full
            <span class="keyword">else</span>
                <span class="keyword">if</span> (size(this,1)*size(this,2)&lt;500000)
                    nIt = 20;
                <span class="keyword">elseif</span> size(this,1)*size(this,2)&lt;5000000
                    nIt = 5;
                <span class="keyword">else</span>
                    nIt = 1;
                <span class="keyword">end</span>
                tMV = 0;
                tMVclose = 0;
                tMVfar = 0;
                <span class="keyword">for</span> i = 1:nIt
                    V = randn(this.N2,1);
                    tMVTic = tic;
                    q = this*V; <span class="comment">%#ok</span>
                    tMV = tMV + toc(tMVTic)/nIt;
                    tMVfarTic = tic;
                    q = this.q2d.conv(this.x,this.y,V); <span class="comment">%#ok</span>
                    tMVfar = tMVfar + 1/nIt*toc(tMVfarTic);
                    tMVcloseTic = tic;
                    q = this.concretePart*V; <span class="comment">%#ok</span>
                    tMVclose = tMVclose + 1/nIt*toc(tMVcloseTic);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            fprintf([alinea <span class="string">'- MV product time : %s s \n'</span>],num2str(tMV));
            fprintf([alinea alinea <span class="string">' %s %% close, %s %% far \n\n'</span> ],num2str(tMVclose/(tMVfar + tMVclose)*100),num2str(tMVfar/(tMVfar + tMVclose)*100));
        <span class="keyword">end</span>
        <span class="keyword">function</span>[str] = memorySize(this)
            NumBytes = this.Nxi*24 + this.NCI*16; <span class="comment">% w_nu double, xi_nu(:,1)</span>
            <span class="comment">% double, xi_nu(:,2) double, complex numbers in close</span>
            str = Bytes2str(NumBytes);
        <span class="keyword">end</span>
</pre><pre class="codeoutput">********************************************* 
GENERAL INFO 

Operator of size 0 x 0 for kernel 
Kernel : function @(x)(oldFunc(lambda*x)) 
Close operator defined for r in [0, 0.00] 
Far operator defined for [0.00, 0.00] 
Number of close interactions : 0
Number of radial quadrature points : 0
</pre><h2>Others<a name="18"></a></h2><pre class="codeinput">        <span class="keyword">function</span>[err,info] = validate(this,V,q,tVal,tol)

            <span class="keyword">if</span> this.full
                disp(<span class="string">'Operator is full, nothing to validate'</span>);
                <span class="keyword">return</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin == 1
                V = randn(size(this,2),1);
                V = V/norm(V,1);
                q = this*V;
                tVal = 2;
                tol = this.tol;
            <span class="keyword">end</span>
            totalTime = tic;
            yy = this.y;
            fun = this.kernel.func;

            xx = this.x(1,:);
            rrxy = sqrt((xx(1)-yy(:,1)).^2 +(xx(2)-yy(:,2)).^2);
            tic; ignoredValue = sum(fun(rrxy).*V); t = toc;  <span class="comment">%#ok just to count time</span>
            NBEM = min(fix(tVal/t/5),size(this,1));
            <span class="keyword">if</span> NBEM == 0
                err = NaN;
                warning(<span class="string">'Could not validate any sample on such a short amount of time'</span>)
            <span class="keyword">else</span>
                shuffle = randperm(size(this,1));
                q2 = zeros(size(this,1),1);
                beginning = tic;
                <span class="keyword">try</span>
                    <span class="keyword">for</span> i = 1:size(this,1)
                        id = shuffle(i);
                        xx = this.x(id,:);
                        rrxy = sqrt((xx(1)-yy(:,1)).^2 +(xx(2)-yy(:,2)).^2);
                        rrxy(rrxy*this.rMax &lt; 1e-8) = 1e-8/this.rMax;
                        q2(i + max(toc(beginning)-tVal,0)*1i) = sum(fun(rrxy).*V);
                    <span class="keyword">end</span>
                <span class="keyword">catch</span>
                    <span class="comment">%raised on purpose</span>
                    i = i-1;
                <span class="keyword">end</span>
                valSample = shuffle(1:i);
                err = norm(q(valSample)-q2(1:i),<span class="string">'inf'</span>);
                t = toc(totalTime);
                <span class="keyword">if</span> err &gt; tol
                    warning(<span class="string">'Found samples with greater error than required accuracy'</span>)
                    info.badSamples = valSample(abs(q(valSample)-q2(1:i))&gt;tol);
                    info.maxErr = err;
                <span class="keyword">else</span>
                    propVal = min(i/size(this,1)*100,100);
                    fprintf(<span class="string">'\n Validated %s%% of the samples in %s seconds \n'</span>,num2str(propVal),num2str(t));
                    info = [];
                    disp(<span class="string">':-)'</span>);
                <span class="keyword">end</span>


            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span>[rm] = rMin(this)
            rm = this.a*this.rMax;
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
    methods (Static)
        <span class="keyword">function</span>[rM] = rMaxCalc(X,Y)
            dist = @(x,x0) max( sqrt( (x(:,1)-x0(1)).^2 + (x(:,2)-x0(2)).^2) );
            rX   = dist(X,mean(X,1));
            rY   = dist(Y,mean(Y,1));
            rXY  = dist(mean(X,1),mean(Y,1));
            rM = rXY + rX  + rY;
        <span class="keyword">end</span>
        <span class="keyword">function</span>[aa] = default_a(N1,N2)
            aa = 1/(4*sqrt(sqrt(N1*N2)));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef Op < AbstractMatrix
    % Op objects represent a matrix A which elements are given by
    % A(i,j) = G(|X(i) - Y(j)|) for some set of points X and Y. However, this
    % object does not store the full matrix, instead it uses a Fourier
    % approximation to reduce the amount of data stored and the time needed
    % for computing a Matrix-Vector product.
    properties
        rMax = 0; % when the user inputs X and Y as data set, rMax is an upper
        % bound of the maximal distance between a point in X and a point in
        % Y. The data set are then rescaled by X/rMax and Y/rMax
        x = [];
        y = []; % rescaled data
        kernel@Kernel = Kernel;% Kernel object. It contains the function G and other information needed for the method
        a = 1; % Bounds of the radial quadrature
        tol = 0; % required accuracy of the approximation
        rq@RadialQuadrature = RadialQuadrature;
        q2d@Quad2D = Quad2D; % Quad2D object, computes the far interaction
        timesClose = struct('total',0,'computeInteractions',0,'computingTree',NaN,'rangeSearch',NaN,...
            'NUFFTcloseField',NaN,'assemble',0);
        timeTotalAssembling = 0; % Timing info
        full = false;
        Y_kdtree = [];
        rxy;
        verbose;
    end
    
    methods (Access = public)
        %% Constructor
        function[op] = Op(X,k,Y,varargin)
            op@AbstractMatrix([],[],0,0);
            tTotalAssembling = tic;
            if nargin == 0
                % Empty Op.
                return
            end
            %% Argument Parsing
            p = inputParser;
            p.KeepUnmatched = true;
            p.addOptional('noCloseField',false); % Set to true to disable close field
            % This is useful when you know that clouds XX and YY are far
            % apart.
            p.addOptional('principalPart',false); % Turn this on if you
            % want to compute the Operator
            % A(i,jà = G_loc|X(i) - Y(j)|
            % Where G_loc is such that there exists a C^\infty function R
            % with
            % G_loc + R = G
            p.addOptional('fullMatrix',false);
            p.addOptional('a',Op.default_a(size(X,1),size(Y,1))); p.addOptional('a_factor',1);
            p.addOptional('tol',1e-8); p.addOptional('precomputedRadialQuad',[]);
            p.addOptional('precomputedKDtree',[]);
            p.addOptional('rMax',Op.rMaxCalc(X,Y));
            p.addOptional('verbose',1);
            % If user wishes to compute a radial quad with specific option,
            % or use several times the same radialquad for different Op
            % object, this is the way to pass it as an argument.
            p.parse(varargin{:});
            optVars = p.Results;
            op.Y_kdtree = optVars.precomputedKDtree;
            
            %% Preparing data and rescaling
            op.rMax = optVars.rMax;
            op.x = X/op.rMax;
            op.y = Y/op.rMax;
            op.N1 = size(X,1);
            op.N2 = size(Y,1);
            op.kernel = k.dilatation(op.rMax);
            op.verbose = optVars.verbose;
            %% Create the operator
            if optVars.fullMatrix
                % The operator is fully assembled.
                
                % the timing information are normally set by the call to
                % Radial
                op = op.computeFullMatrix;
                % Computes all the Nx*Ny interactions
                % Also sets the timesClose struct.
            else
                % A radial quadrature is performed on the kernel for the
                % far interactions
                % Local interactions are computed explicitly
                op.tol = optVars.tol;
                op.a = optVars.a_factor*optVars.a;
                
                %% Far operator
                if isempty(optVars.precomputedRadialQuad)
                    op.rq = op.kernel.radialQuadKernel(op.a,op.tol,varargin{:});
                else
                    op.rq = optVars.precomputedRadialQuad;
                end
                op.q2d = Quad2D(op.rq);
                
                %% Local Part
                if ~or(isa(op.kernel,'J0Kernel'),optVars.noCloseField)
                    op = createLocalPart(op);
                    % Computes the local interactions
                    % Also sets the timesClose struct;
                else
                    % No need to compute the close interactions.
                    op.concretePart = sparse([],[],[],op.N1,op.N2);
                    if optVars.noCloseField
                        rMinTest = op.rMinTest;
                        if rMinTest < op.a*op.rMax
                            warning(['There are pairs of points closer than ', ...
                            'parameter ''a''. It was however requested not ',...
                            'to compute the local interactions. This may lead to',... 
                            ' inaccurate results']);
                        end
                    end
                end
                if optVars.principalPart
                    % Erase the radial quadratue components
                    op.rq = RadialQuadrature;
                    op.q2d = Quad2D;
                end
                op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
            end
            
            op.timeTotalAssembling = toc(tTotalAssembling);
        end
        %% Immediate properties
        function[nxi] = Nxi(this,test_a)
            if nargin == 1
                nxi = this.q2d.Nxi;
            else
                rq_test = this.kernel.radialQuadKernel(test_a,this.tol);
                nxi = sum(fix(exp(1)/2*0.8*rq_test.rho + 5*log(1/(this.tol+10^(-10)))));
            end
        end
        function[out] = NCI(op,test_a)
            if nargin == 1
                out = nnz(op.concretePart);
            else
                if isempty(op.Y_kdtree)
                    I = rangesearch(op.Y,op.X,op.rMax*test_a*1.05);
                else
                    I = rangesearch(op.Y_kdtree,op.X,op.rMax*test_a*1.05);
                end
                out = length(cell2mat(I')');
            end
        end
        function[tFar] = timesFar(this)
            tFar.radialQuadrature = this.rq.times.total;
            tFar.quad2D = this.q2d.time;
            tFar.total = tFar.radialQuadrature + tFar.quad2D;
        end
        function[r] = rMinTest(this)
            % First pass
            x1 = this.x(1,:);
            [~,ind] = min(sqrt((x1(1) - this.y(:,1)).^2 + (x1(2) - this.y(:,2)).^2));
            y1 = this.y(ind,:);
            % Second pass
            [~,ind] = min(sqrt((this.x(:,1) - y1(1)).^2 + (this.x(:,2) - y1(2)).^2));
            x2 = this.x(ind,:);
            [~,ind] = min(sqrt((x2(1) - this.y(:,1)).^2 + (x2(2) - this.y(:,2)).^2));
            y2 = this.y(ind,:);
            % Third pass
            [~,ind] = min(sqrt((this.x(:,1) - y2(1)).^2 + (this.x(:,2) - y2(2)).^2));
            x3 = this.x(ind,:);
            [~,ind] = min(sqrt((x3(1) - this.y(:,1)).^2 + (x3(2) - this.y(:,2)).^2));
            y3 = this.y(ind,:);
            r = norm(x3 - y3,2)*this.rMax;
        end
        function[X] = X(op)
            X = op.x * op.rMax;
        end
        function[Y] = Y(op)
            Y = op.y * op.rMax;
        end
        function[out] = a_factor(op)
            % Size of parameter a compared to default value.
            out = op.a/Op.default_a(op.N1,op.N2);
        end
        
        %% Setters
        function[op] = createLocalPart(op)
            times.rangeSearch = 0;
            times.computeInteractions = 0;
            times.NUFFTcloseField = 0;
            times.assemble = 0;
            tTotalTime = tic;
            % Find close interactions
            tRangeSearch = tic;
            times.computingTree = 0;
            if isempty(op.Y_kdtree)
                tComputingTree = tic;
                op.Y_kdtree = KDTreeSearcher(op.Y);
                times.computingTree = toc(tComputingTree);
            end
            [I,rxyTemp] = rangesearch(op.Y_kdtree,op.X,op.rMax*op.a*1.05);
            jdx = cell2mat(I')';
            op.rxy = cell2mat(rxyTemp')'/op.rMax;
            idx = zeros(size(jdx));
            sp_ind = 1;
            for x_ind=1:length(I);
                idx(sp_ind:(sp_ind+length(I{x_ind})-1)) = x_ind;
                sp_ind = sp_ind + length(I{x_ind});
            end
            % Save memory
            clear I;
            times.rangeSearch = toc(tRangeSearch);
            NCI = length(op.rxy);
            Nxi = op.q2d.Nxi;
            % close-field
            if NCI ~= 0
                tComputeInteractions = tic;
                rxyApply = op.rxy;
                rxyApply(rxyApply*op.rMax < 1e-8) = 1e-8/op.rMax;
                B1_inds = op.kernel.func(rxyApply);
                %B1_inds(or(isinf(B1_inds),isnan(B1_inds))) = op.kernel.func(1e-8/op.rMax);
                
                times.computeInteractions = toc(tComputeInteractions);
                
                % local correction of error due to NUFFT
                if op.verbose >=1
                    fprintf('NUFFT for local correction : *')
                end
                tNUFFTcloseField = tic;
                B2_inds = nufft2d3(Nxi, op.q2d.xi_nu(:,1), op.q2d.xi_nu(:,2), ...
                    op.q2d.w_nu, +1, op.tol/10, length(idx),...
                    op.x(idx,1) - op.y(jdx,1), op.x(idx,2) - op.y(jdx,2));
                times.NUFFTcloseField = toc(tNUFFTcloseField);
                
                % Sparse matrix
                tAssemble = tic;
                B_inds = B1_inds - B2_inds - op.q2d.offset;
                op.concretePart = sparse(idx,jdx,B_inds,op.N1,op.N2);
                times.assemble = toc(tAssemble);
            else
                % No close interactions
                op.concretePart = sparse(op.N1,op.N2); % all zeros
            end
            
            times.total = toc(tTotalTime);
            op.timesClose = times;
            
        end
        function[op] = update_X(op,X,varargin)
            tUpdating = tic;
            p = inputParser;
            p.addOptional('a',op.a);
            p.addOptional('tol',op.tol);
            p.addOptional('principalPart',false);
            p.addOptional('a_factor',1);
            p.parse(varargin{:});
            % Replace the operator by A(i,j) = G(|X(i) - Y(j)|) with new X
            % data.
            % 1°) New rescaling
            rMaxNew = Op.rMaxCalc(X,op.Y);
            if any([rMaxNew > op.rMax,op.tol > p.Results.tol, p.Results.a*p.Results.a_factor ~= op.a])
                % Then we have to update the quadrature since it is not
                % valid up to rMaxTest or to requested tolerance
                disp('Recomputing a quadrature');
                rMaxPrevious = op.rMax;
                op.rMax = rMaxNew;
                op.x = X/op.rMax;
                op.y = op.y*rMaxPrevious/op.rMax;
                op.a = p.Results.a*p.Results.a_factor;
                op.N1 = size(X,1);
                op.kernel = op.kernel.dilatation(rMaxNew/rMaxPrevious);
                if op.full
                    op = op.computeFullMatrix;
                else
                    op.rq = op.kernel.radialQuadKernel(op.a,op.tol);
                    op.q2d = Quad2D(op.rq);
                    if p.Results.principalPart
                        % Erase the radial quadratue components
                        op.rq = RadialQuadrature;
                        op.q2d = Quad2D;
                    end
                end
            else
                % We can reuse the previous quadrature
                op.x = X/op.rMax;
                op.N1 = size(X,1);
            end
            op = op.createLocalPart;
            op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
            op.timeTotalAssembling = toc(tUpdating);
        end
        function[op] = change_a(op,new_a)
            op.a = new_a;
            op.rq = op.kernel.radialQuadKernel(op.a,op.tol);
            op.q2d = Quad2D(op.rq);
            %% Local Part
            % If we decrease a, we just have to remove the pairs that are a
            % bit too far. 
            if ~isa(op.kernel,'J0Kernel')
                op = op.createLocalPart;
                % Computes the local interactions
                % Also sets the timesClose struct
            end
            op.abstractPart = @(vec)(op.q2d.conv(op.x,op.y,vec));
        end
        function[op] = balanceMemory(op)
            Nxi = op.Nxi;
            NCI = op.NCI;
            NCI0 = NCI;
            memClose = NCI*16;
            memFar = Nxi*24;
            alpha = 1; % Guessed dependance of NCI in variable a. 
            dataAlpha = [];
            a0 = op.a;
            a_current = a0;
            while or(memClose>10*memFar,memClose < memFar/10)
                % Find out if memory usage is ok
                lambdaGuess = (memFar/memClose)^(1/(alpha+2));
                a_current = lambdaGuess*a0;
                Nxi = op.Nxi(a_current);
                NCI = op.NCI(a_current);
                memClose = NCI*16;
                memFar = Nxi*24;
                dataAlpha = [dataAlpha,log(NCI/NCI0)/log(a_current/a0)];%#ok 
                alpha = mean(dataAlpha);
            end
            op = op.change_a(a_current);
        end
        function[op] = balanceTime(op)
            Vtest = randn(size(op,2),1);
            tClose = tic;
            q_close_test = op.concretePart*Vtest;%#ok 
            tClose = toc(tClose);
            if tClose < 0.01
                tClose = tic;
                for i = 1:10
                    q_close_test = op.concretePart*Vtest;%#ok 
                end
                tClose = toc(tClose)/10;
            end
            tFar = tic;
            q_far_test = op.abstractPart(Vtest);%#ok 
            tFar = toc(tFar);
            while or(tClose>5*tFar,tClose < tFar/5)
                if tClose > tFar
                    lambda = 0.75;
                else
                    lambda = 1.25;
                    try 
                        MemTest = ones(fix(1.5*op.NCI),1); %#ok
                        clear A;
                    catch
                        break
                    end
                end
                if lambda*op.a > 1
                    return
                end
                op = op.change_a(lambda*op.a);
                tClose = tic;
                q_close_test = op.concretePart*Vtest;%#ok 
                tClose = toc(tClose);
                if tClose < 0.01
                    tClose = tic;
                    for i = 1:10
                        q_close_test = op.concretePart*Vtest;%#ok
                    end
                    tClose = toc(tClose)/10;
                end
                tFar = tic;
                q_far_test = op.abstractPart(Vtest);%#ok 
                tFar = toc(tFar);
            end
        end
        function[op] = computeFullMatrix(op)
            tTotalAssembling = tic;
            op.timesClose.rangesearch = 0;
            
            op.timesClose.NUFFTcloseField = 0;
            
            X1 = op.x(:,1); X2 = op.x(:,2);
            Y1 = op.y(:,1); Y2 = op.y(:,2);
            NX = length(X1);
            NY = length(Y1);
            tComputeInteractions = tic;
            X1_Y1 = repmat(X1,1,NY) - repmat(Y1',NX,1);
            X2_Y2 = repmat(X2,1,NY) - repmat(Y2',NX,1);
            rXY = sqrt(X1_Y1.^2 + X2_Y2.^2);
            op.timesClose.computeInteractions = toc(tComputeInteractions);
            op.concretePart = op.kernel.func(rXY);
            op.concretePart(or(isnan(op.concretePart),...
                isinf(op.concretePart))) = op.kernel.func(1e-8/op.rMax);
            op.timeTotalAssembling = toc(tTotalAssembling);
            op.full = true;
            op.timesClose.total = toc(tTotalAssembling);
        end

        %% Display
        function[] = disp(this)
            printStarLine;
            fprintf('GENERAL INFO \n')
            fprintf('\nOperator of size %s x %s for kernel \n',num2str(size(this,1)),num2str(size(this,2)));
            disp(this.kernel.dilatation(1/this.rMax));
            if this.full
                printStarLine;
                fprtinf('Operator is FULLY assmbled \n');
            else
                rm = this.rMin;
                rM = this.rMax;
                fprintf('Close operator defined for r in [0, %.2f] \n',rm);
                fprintf('Far operator defined for [%.2f, %.2f] \n',rm,rM);
                fprintf('Number of close interactions : %s\n',num2str(this.NCI));
                fprintf('Number of radial quadrature points : %s\n',num2str(length(this.rq.rho) - 1));
                fprintf('Number of 2D quadrature points : %s\n',num2str(this.Nxi));
            end
        end
        function[] = show(this)
            disp(this);
            showTime(this);
            showPerf(this);
            show(this.rq);
        end
        function[] = showTime(this)
            printStarLine;
            tClose = this.timesClose.total;
            tFar = this.timesFar.total;
            tTot = tClose + tFar;
            if this.full
                fprintf('Operator assembled FULLY in %s s\n',tTot);
            else
                fprintf('OFFLINE PERFORMANCE \n')
                fprintf('\n- Operator assembling : %.2f s  :\n',tTot);
                alinea =  '     ';
                
                fprintf([alinea '- Close operator : %.2f s (%.2f %%): \n'],tClose,tClose/tTot*100);
                if this.timesClose.computingTree == 0
                    fprintf([alinea alinea '* KD-tree : 0 %% (precomputed)\n']);
                else
                    fprintf([alinea alinea '* KD-tree : %.2f %% \n'],this.timesClose.computingTree/tClose*100);
                end
                fprintf([alinea alinea '* Range search : %.2f %% \n'],this.timesClose.rangeSearch/tClose*100);
                fprintf([alinea alinea '* Computation of close interactions : %.2f %% \n'],this.timesClose.computeInteractions/tClose*100);
                fprintf([alinea alinea '* Local correction of the far-field (NUFFT) : %.2f %% \n'],this.timesClose.NUFFTcloseField/tClose*100);
                fprintf([alinea alinea '* Assembling close operator : %.2f %% \n'],this.timesClose.assemble/tClose*100);
                
                
                fprintf([alinea '- Far operator : %.2f s (%.2f %%): \n'],tFar,tFar/tTot*100);
                fprintf([alinea alinea '* Radial quadrature : %.2f %% \n'],this.timesFar.radialQuadrature/tFar*100);
                fprintf([alinea alinea '* 2D quadrature : %.2f %% \n'],this.timesFar.quad2D/tFar*100);
            end
            
        end
        function[] = showPerf(this)
            printStarLine;
            alinea =  '     ';
            
            fprintf('ONLINE PERFORMANCE \n')
            % Memory
            fprintf('\n- Memory allocation : %s \n',this.memorySize)
            if this.full
                fprintf('Operator is fully assembled \n')
            else
                sparsityConst = this.NCI/(size(this,1)*size(this,2));
                fprintf([alinea '- Close operator : %.2f %% (%.2f %% sparsity)\n'],this.NCI*2/(this.Nxi*3 + this.NCI*2)*100,100 - sparsityConst*100);
                fprintf([alinea '- Far operator : %.2f %%\n'],this.Nxi/(this.Nxi + this.NCI)*100)
                if (this.NCI*2 > this.Nxi*3)
                    str_for_a = 'reduce';
                else
                    str_for_a = 'increase';
                end
                if or(2*this.NCI > 10*3*this.Nxi,2*this.NCI < 1/10*3*this.Nxi)
                    fprintf('(for more balanced memory allocation, %s parameter ''a'') \n',str_for_a);
                end
            end
            
            % Chrono of MV prod
            if this.full
            else
                if (size(this,1)*size(this,2)<500000)
                    nIt = 20;
                elseif size(this,1)*size(this,2)<5000000
                    nIt = 5;
                else
                    nIt = 1;
                end
                tMV = 0;
                tMVclose = 0;
                tMVfar = 0;
                for i = 1:nIt
                    V = randn(this.N2,1);
                    tMVTic = tic;
                    q = this*V; %#ok
                    tMV = tMV + toc(tMVTic)/nIt;
                    tMVfarTic = tic;
                    q = this.q2d.conv(this.x,this.y,V); %#ok
                    tMVfar = tMVfar + 1/nIt*toc(tMVfarTic);
                    tMVcloseTic = tic;
                    q = this.concretePart*V; %#ok
                    tMVclose = tMVclose + 1/nIt*toc(tMVcloseTic);
                end
            end
            fprintf([alinea '- MV product time : %s s \n'],num2str(tMV));
            fprintf([alinea alinea ' %s %% close, %s %% far \n\n' ],num2str(tMVclose/(tMVfar + tMVclose)*100),num2str(tMVfar/(tMVfar + tMVclose)*100));
        end
        function[str] = memorySize(this)
            NumBytes = this.Nxi*24 + this.NCI*16; % w_nu double, xi_nu(:,1)
            % double, xi_nu(:,2) double, complex numbers in close
            str = Bytes2str(NumBytes);
        end
        %% Others
        function[err,info] = validate(this,V,q,tVal,tol)
            
            if this.full
                disp('Operator is full, nothing to validate');
                return
            end
            if nargin == 1
                V = randn(size(this,2),1);
                V = V/norm(V,1);
                q = this*V;
                tVal = 2;
                tol = this.tol;
            end
            totalTime = tic;
            yy = this.y;
            fun = this.kernel.func;
            
            xx = this.x(1,:);
            rrxy = sqrt((xx(1)-yy(:,1)).^2 +(xx(2)-yy(:,2)).^2);
            tic; ignoredValue = sum(fun(rrxy).*V); t = toc;  %#ok just to count time
            NBEM = min(fix(tVal/t/5),size(this,1));
            if NBEM == 0
                err = NaN;
                warning('Could not validate any sample on such a short amount of time')
            else
                shuffle = randperm(size(this,1));
                q2 = zeros(size(this,1),1);
                beginning = tic;
                try
                    for i = 1:size(this,1)
                        id = shuffle(i);
                        xx = this.x(id,:);
                        rrxy = sqrt((xx(1)-yy(:,1)).^2 +(xx(2)-yy(:,2)).^2);
                        rrxy(rrxy*this.rMax < 1e-8) = 1e-8/this.rMax;
                        q2(i + max(toc(beginning)-tVal,0)*1i) = sum(fun(rrxy).*V);
                    end
                catch
                    %raised on purpose
                    i = i-1;
                end
                valSample = shuffle(1:i);
                err = norm(q(valSample)-q2(1:i),'inf');
                t = toc(totalTime);
                if err > tol
                    warning('Found samples with greater error than required accuracy')
                    info.badSamples = valSample(abs(q(valSample)-q2(1:i))>tol);
                    info.maxErr = err;
                else
                    propVal = min(i/size(this,1)*100,100);
                    fprintf('\n Validated %s%% of the samples in %s seconds \n',num2str(propVal),num2str(t));
                    info = [];
                    disp(':-)');
                end
                
                
            end
        end
        function[rm] = rMin(this)
            rm = this.a*this.rMax;
        end
        
    end
    methods (Static)
        function[rM] = rMaxCalc(X,Y)
            dist = @(x,x0) max( sqrt( (x(:,1)-x0(1)).^2 + (x(:,2)-x0(2)).^2) );
            rX   = dist(X,mean(X,1));
            rY   = dist(Y,mean(Y,1));
            rXY  = dist(mean(X,1),mean(Y,1));
            rM = rXY + rX  + rY;
        end
        function[aa] = default_a(N1,N2)
            aa = 1/(4*sqrt(sqrt(N1*N2)));
        end
    end
end


##### SOURCE END #####
--></body></html>